根据您的要求，我制定了将自定义题目纳入 `questions` 表统一管理的重构计划。

### 1. 数据库迁移 (Database Migration)

创建新的 SQL 迁移文件 `supabase/migrations/20260212_refactor_questions_schema.sql`，执行以下变更：

* **字段修改**：将 `book_no` 和 `test_no` 修改为 **可空 (Nullable)**。

* **新增字段**：添加 `user_id` 字段（UUID，关联 `auth.users`），用于标识自定义题目所属用户。

* **约束更新**：

  * 删除旧的唯一约束 `questions_book_test_task_unique`。

  * 添加针对官方题目的新唯一约束：当 `user_id` 为空时，`(book_no, test_no, task_type)` 必须唯一。

  * 添加针对自定义题目的索引/约束：建议对 `(user_id, content)` 建立唯一索引，防止同一用户重复创建相同内容的题目。

* **RLS 策略更新**：

  * `SELECT`: 允许用户查询 `user_id` 为空的题目（官方题）**或** `user_id` 等于当前用户 ID 的题目。

  * `INSERT`: 允许用户插入 `user_id` 等于当前用户 ID 的题目。

### 2. 类型定义更新 (Type Definitions)

更新 `src/types/question.ts`：

* `book_no` 和 `test_no` 标记为可选属性 (`?`)。

* 新增 `user_id?: string` 属性。

### 3. 业务逻辑重构 (Business Logic Refactor)

#### A. 写作页面 (`src/app/workshop/page.tsx`)

重构提交前的处理逻辑：

* 当用户进入页面且没有关联 `question_id`（即自定义题目模式）时，在用户点击“开始评分”或“提交”时：

  1. 检查 `questions` 表中是否已存在该用户创建的相同内容的题目。
  2. 如果不存在，自动向 `questions` 表插入一条新记录（`user_id` 为当前用户，`book_no/test_no` 为空，`topic` 默认为 "Custom Topic" 或用户输入内容）。
  3. 获取该题目的 `id`。
  4. 将这个 `id` 作为 `question_id` 写入到 `essays` 表中，确保每一篇作文都关联到一个具体的 Question 实体。

#### B. 题目列表页面 (`src/app/questions/page.tsx`)

重构数据获取和聚合逻辑：

* **简化查询**：直接查询 `questions` 表。由于 RLS 的存在，用户会自动获取到“官方库 + 自己的自定义题库”。

* **统一聚合**：

  * 移除原本针对 `question_id` 为空的特殊聚合逻辑。

  * 所有题目（无论官方还是自定义）统一使用 `question_id` 关联 `essays` 历史记录。

  * 界面渲染逻辑保持一致，不再需要“伪造”题目对象。

### 4. 验证计划 (Verification)

* 验证官方题目展示是否正常。

* 验证创建新的自定义题目后，是否能在 Questions 列表中看到。

* 验证自定义题目的历史记录功能是否正常工作（点击 History 能看到同一题目的多次练习）。

